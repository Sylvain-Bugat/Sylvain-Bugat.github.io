<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>8 Queens Puzzle on Batch cavern</title>
    <link>http://sylvain-bugat.github.io/categories/8-queens-puzzle/</link>
    <description>Recent content in 8 Queens Puzzle on Batch cavern</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 May 2015 00:18:54 +0200</lastBuildDate>
    <atom:link href="http://sylvain-bugat.github.io/categories/8-queens-puzzle/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>8 queens puzzle brute-force solvers part 4</title>
      <link>http://sylvain-bugat.github.io/blog/2015/05/14/8-queens-puzzle-brute-force-solvers-part-4/</link>
      <pubDate>Thu, 14 May 2015 00:18:54 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/05/14/8-queens-puzzle-brute-force-solvers-part-4/</guid>
      <description>

&lt;h2 id=&#34;one-queen-per-line:0455adfa2265028898e1e89424046c1a&#34;&gt;One queen per line&lt;/h2&gt;

&lt;h3 id=&#34;explaination:0455adfa2265028898e1e89424046c1a&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;One one queen can be placed per line, so when a queen is placed on any line it&amp;rsquo;s useless to put one or more queens on the remaining position of this line.&lt;/p&gt;

&lt;p&gt;For example with this chessboard, it&amp;rsquo;s useless to put a queen on the last 7 positions:&lt;/p&gt;

&lt;div id=&#34;board&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;,
  b8: &#39;rQ&#39;,
  c8: &#39;rQ&#39;,
  d8: &#39;rQ&#39;,
  e8: &#39;rQ&#39;,
  f8: &#39;rQ&#39;,
  g8: &#39;rQ&#39;,
  h8: &#39;rQ&#39;
};
var board = new ChessBoard(&#39;board&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;h3 id=&#34;implementation:0455adfa2265028898e1e89424046c1a&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with a two dimensional array and a next line skip after placing a queen on a line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a 2 dimensional array. */
private boolean[][] chessboard;
/** Array to count queens on each column. */
private int[] columnCounts;
/** Array to count queens on ascending diagonals, diagonal number = x + y. */
private int[] ascendingDiagonalCounts;
/** Array to count queens on descending diagonals, diagonal number = x + chess board size - 1 - y. */
private int[] descendingDiagonalCounts;

/** Current number of placedQueens */
private int placedQueens;
    
private void solve(final int x, final int y) {

    // Put a queen on the current position
    chessboard[y][x] = true;
    columnCounts[x]++;
    final int ascendingDiagnonal = x + y;
    final int descendingDiagnonal = x + chessboardSize - 1 - y;
    ascendingDiagonalCounts[ascendingDiagnonal]++;
    descendingDiagonalCounts[descendingDiagnonal]++;
    placedQueens++;

    // All queens are sets then a solution may be present
    if (placedQueens &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    }
    else {

        //End of chessboard check
        if (y + 1 &amp;lt; chessboardSize) {
            //Go to the next line
            solve(0, y + 1);
        }
    }

    // Remove the placed queen
    placedQueens--;
    ascendingDiagonalCounts[ascendingDiagnonal]--;
    descendingDiagonalCounts[descendingDiagnonal]--;
    columnCounts[x]--;
    chessboard[y][x] = false;

    //End of line check
    if (x + 1 &amp;lt; chessboardSize) {
        //Go to the next position on the line
        solve(x + 1, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverOneQueenPerLine.java&#34;&gt;BruteForceNQueensSolverOneQueenPerLine&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:0455adfa2265028898e1e89424046c1a&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;6.03 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;61.93 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;997.29 µs&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;22.05 ms&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;404.07 ms&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;7,41 s&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 10x10 chessboard, the needed time to count all solutions is long.&lt;/p&gt;

&lt;h2 id=&#34;reduced-recursion:0455adfa2265028898e1e89424046c1a&#34;&gt;Reduced recursion&lt;/h2&gt;

&lt;h3 id=&#34;explaination-1:0455adfa2265028898e1e89424046c1a&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;A single recursive call can be used on each line to test sequentially each possible position. On a N x N chessboard, only N recursive calls are needed to test all possible combinations.&lt;/p&gt;

&lt;h3 id=&#34;implementation-1:0455adfa2265028898e1e89424046c1a&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with a &lt;code&gt;for&lt;/code&gt; loop to test all possible positions on each line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a 2 dimensional array. */
private boolean[][] chessboard;
/** Array to count queens on each column. */
private int[] columnCounts;
/** Array to count queens on ascending diagonals, diagonal number = x + y. */
private int[] ascendingDiagonalCounts;
/** Array to count queens on descending diagonals, diagonal number = x + chess board size - 1 - y. */
private int[] descendingDiagonalCounts;

private void solve(final int y) {

    for (int x = 0; x &amp;lt; chessboardSize; x++) {

        // Put a queen on the current position
        chessboard[y][x] = true;
        columnCounts[x]++;
        final int ascendingDiagnonal = x + y;
        final int descendingDiagnonal = x + chessboardSize - 1 - y;
        ascendingDiagonalCounts[ascendingDiagnonal]++;
        descendingDiagonalCounts[descendingDiagnonal]++;

        // Last line: all queens are sets then a solution may be present
        if (y + 1 &amp;gt;= chessboardSize) {
            if (checkSolutionChessboard()) {
                solutionCount++;
                print();
            }
        }
        else {
            // Go to the next line
            solve(y + 1);
        }

        // Remove the placed queen
        ascendingDiagonalCounts[ascendingDiagnonal]--;
        descendingDiagonalCounts[descendingDiagnonal]--;
        columnCounts[x]--;
        chessboard[y][x] = false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverReducedRecursion.java&#34;&gt;BruteForceNQueensSolverReducedRecursion&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks-1:0455adfa2265028898e1e89424046c1a&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;6.48 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;60.74 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;850.48 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;18.08 ms&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;323.31 ms&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;8.79 s&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;3.32 m&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 10x10 chessboard, the needed time to count all solutions is long!&lt;/p&gt;

&lt;h2 id=&#34;next-optimisations:0455adfa2265028898e1e89424046c1a&#34;&gt;Next optimisations?&lt;/h2&gt;

&lt;p&gt;Other optimisations will be tested in the part 5, stay tuned of go to the &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers&#34;&gt;GitHub project&lt;/a&gt; to have some algorithms preview!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8 queens puzzle brute-force solvers part 3</title>
      <link>http://sylvain-bugat.github.io/blog/2015/05/09/8-queens-puzzle-brute-force-solvers-part-3/</link>
      <pubDate>Sat, 09 May 2015 00:12:54 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/05/09/8-queens-puzzle-brute-force-solvers-part-3/</guid>
      <description>

&lt;h2 id=&#34;use-a-one-dimensional-array-for-the-chessboard:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Use a one-dimensional array for the chessboard&lt;/h2&gt;

&lt;h3 id=&#34;explaination:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;The data structure used to represent the chessboard can be changed from a two-dimensional array to a one-dimensional array. Recursive calls are faster because all N x N positions are sequentially acceded.&lt;/p&gt;

&lt;h3 id=&#34;implementation:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with a one-dimention array to represent the chessboard, his size is equal to N x N:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard with only one dimension with all lines. */
private final boolean[] chessboard;
/** Current number of placedQueens */
private int placedQueens;

private void solve(final int position) {

    // Put a queen on the current position
    chessboard[position] = true;
    placedQueens++;

    // All queens are sets then a solution may be present
    if (placedQueens &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    }
    else {

        // End of the chessboard check
        if (position + 1 &amp;lt; chessboard.length) {
            solve(position + 1);
        }
    }

    // Remove the queen on the current position
    placedQueens--;
    chessboard[position] = false;

    // End of the chessboard check
    if (position + 1 &amp;lt; chessboard.length) {
        solve(position + 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverOneDimensionArray.java&#34;&gt;BruteForceNQueensSolverOneDimensionArray&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;67.70 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1.82 ms&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;67.17 ms&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;3.11 s&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;2.42 m&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;3h02m&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 9x9 chessboard, the needed time to count all solutions is very long!&lt;/p&gt;

&lt;h2 id=&#34;add-grid-constraints:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Add grid constraints&lt;/h2&gt;

&lt;h3 id=&#34;explaination-1:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;In the N-queens-puzzle, the number of currently placed queens per column, line and diagonals can stored in arrays variables, when a queen is put on the chessboard theses variables are incremented at the correct offsets and when a queen is removed theses variables must be decremented at the same offsets.&lt;/p&gt;

&lt;h3 id=&#34;implementation-1:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with 4 new constraints for lines, columns and both diagnonals:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard with only one dimension with all lines. */
private boolean[] chessboard;
/** Array to count queens on each column. */
private int[] columnCounts;
/** Array to count queens on each line. */
private int[] lineCounts;
/** Array to count queens on ascending diagonals, diagonal number = x + y. */
private int[] ascendingDiagonalCounts;
/** Array to count queens on descending diagonals, diagonal number = x + chessboard size - 1 - y. */
private int[] descendingDiagonalCounts;

private void solve(final int position) {

    // Recalculate X and Y coordinates
    final int y = position / chessboardSize;
    final int x = position % chessboardSize;

    // Put a queen on the current position
    chessboard[position] = true;
    lineCounts[y]++;
    columnCounts[x]++;
    final int ascendingDiagonal = x + y;
    final int descendingDiagnonal = x + chessboardSize - 1 - y;
    ascendingDiagonalCounts[ascendingDiagonal]++;
    descendingDiagonalCounts[descendingDiagonal]++;
    placedQueens++;

    // All queens are sets then a solution may be present
    if (placedQueens &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    }
    else {

        // End of the chessboard check
        if (position + 1 &amp;lt; chessboard.length) {
            solve(position + 1);
        }
    }

    // Remove the queen on the current position
    placedQueens--;
    ascendingDiagonalCounts[ascendingDiagonal]--;
    descendingDiagonalCounts[descendingDiagonal]--;
    lineCounts[y]--;
    columnCounts[x]--;
    chessboard[position] = false;

    // End of the chessboard check
    if (position + 1 &amp;lt; chessboard.length) {
        solve(position + 1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverGridConstraits.java&#34;&gt;BruteForceNQueensSolverGridConstraits&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks-1:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;55,98 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;1,75 ms&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;54,57 ms&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;2,37 s&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1.54 m&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;2.05 h&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 9x9 chessboard, the needed time to count all solutions is very long!&lt;/p&gt;

&lt;h2 id=&#34;next-optimisations:6d48f140073f9b96eac74e4a8cc818ba&#34;&gt;Next optimisations?&lt;/h2&gt;

&lt;p&gt;Next optimisations are tested in the part 4, click on the link below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8 queens puzzle brute-force solvers part 2</title>
      <link>http://sylvain-bugat.github.io/blog/2015/05/06/8-queens-puzzle-brute-force-solvers-part-2/</link>
      <pubDate>Wed, 06 May 2015 20:46:15 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/05/06/8-queens-puzzle-brute-force-solvers-part-2/</guid>
      <description>

&lt;h2 id=&#34;adding-a-queen-constraint:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Adding a queen constraint&lt;/h2&gt;

&lt;h3 id=&#34;explaination:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Constraint_programming&#34;&gt;Constraint programming&lt;/a&gt; consists of use some data structure to store some contraints that can be modified and checked faster than recompute it at each algorithm step.&lt;/p&gt;

&lt;p&gt;In the N-queens-puzzle, the number of currently placed queens can stored in a variable, when a queen is put on the chessboard this variable must be incremented and when a queen is remove this variable must be decremented.&lt;/p&gt;

&lt;h3 id=&#34;implementation:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with a queen counter (variable  &lt;code&gt;placedQueens&lt;/code&gt;)  limit of N placed queens at the same time on the chessboard:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a list of lists. */
private final List&amp;lt;List&amp;lt;Boolean&amp;gt;&amp;gt; chessboard;
/** Current number of queens on the chessboard. */
private int placedQueens;

private void solve(final int x, final int y) {

    // Put a queen on the current position
    chessboard.get(x).set(y, Boolean.TRUE);
    placedQueens++;

    // All queens are sets then a solution may be present
    if (placedQueens &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    }
    else {

        // Recursive call to the next position
        final int nextX = (x + 1) % chessboardSize;
        // Switch to the next line
        if (0 == nextX) {

            // End of the chessboard check
            if (y + 1 &amp;lt; chessboardSize) {
                solve(nextX, y + 1);
            }
        }
        else {
            solve(nextX, y);
        }
    }

    // Remove the queen on the current position
    placedQueens--;
    chessboard.get(x).set(y, Boolean.FALSE);

    // Recursive call to the next position
    final int nextX = (x + 1) % chessboardSize;
    // Switch to the next line
    if (0 == nextX) {

        // End of the chessboard check
        if (y + 1 &amp;lt; chessboardSize) {
            solve(nextX, y + 1);
        }
    }
    else {
        solve(nextX, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverWithLists.java&#34;&gt;BruteForceNQueensSolverWithLists&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;146.68 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;4.24 ms&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;162.88 ms&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;7.49 s&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;6.20 m&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;6.10 h&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 9x9 chessboard, the needed time to count all solutions is very long!&lt;/p&gt;

&lt;h2 id=&#34;algorithms-comparisons:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Algorithms comparisons&lt;/h2&gt;

&lt;p&gt;Comparison of the previous and this algorithm:&lt;/p&gt;

&lt;div class=&#34;panel panel-default tab-box&#34;&gt;
    &lt;div class=&#34;panel-heading&#34;&gt;
        &lt;h3 class=&#34;panel-title&#34;&gt;
            &lt;i class=&#34;fa fa-signal&#34;&gt;&lt;/i&gt;Algorithms comparison
        &lt;/h3&gt;
        &lt;ul class=&#34;nav nav-tabs&#34;&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix1queenPlacementsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix1queenPlacementsGraph&#34;&gt;moves&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&#34;active&#34;&gt;
                &lt;a href=&#34;#prefix1methodCallsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix1methodCallsGraph&#34;&gt;method calls&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix1squareReadsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix1squareReadsGraph&#34;&gt;reads&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix1explicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix1explicitTestsGraph&#34;&gt;tests&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix1implicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix1implicitTestsGraph&#34;&gt;loop tests&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&#34;panel-body&#34;&gt;
        &lt;div class=&#34;tab-content&#34;&gt;
            &lt;div id=&#34;prefix1queenPlacementsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Queen placements count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix1queenPlacements&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;List brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix1methodCallsTab&#34; class=&#34;tab-pane active&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Method calls count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix1methodCalls&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;List brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix1squareReadsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Square reads count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix1squareReads&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;List brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix1explicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Explicit tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix1explicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;List brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix1implicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Loop tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix1implicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;List brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;

$(&#39;ul.nav a&#39;).on(&#39;shown.bs.tab&#39;, function (e) {
    var types = $(this).attr(&#34;data-identifier&#34;);
    var typesArray = types.split(&#34;,&#34;);
    $.each(typesArray, function (key, value) {
        eval(value + &#34;.redraw()&#34;);
        eval(value + &#34;.resizeHandler()&#34;);
    })
});

//Data
var prefix1data = [
    {&#34;size&#34;: &#34;1&#34;, &#34;solver1queenPlacements&#34;: 1,  &#34;solver1methodCalls&#34;: 23,  &#34;solver1squareReads&#34;: 5,  &#34;solver1explicitTests&#34;: 17,  &#34;solver1implicitTests&#34;: 21,  &#34;solver2queenPlacements&#34;: 1,  &#34;solver2methodCalls&#34;: 19,  &#34;solver2squareReads&#34;: 4,  &#34;solver2explicitTests&#34;: 16,  &#34;solver2implicitTests&#34;: 17},
    {&#34;size&#34;: &#34;2&#34;, &#34;solver1queenPlacements&#34;: 10,  &#34;solver1methodCalls&#34;: 324,  &#34;solver1squareReads&#34;: 86,  &#34;solver1explicitTests&#34;: 175,  &#34;solver1implicitTests&#34;: 200,  &#34;solver2queenPlacements&#34;: 10,  &#34;solver2methodCalls&#34;: 194,  &#34;solver2squareReads&#34;: 46,  &#34;solver2explicitTests&#34;: 135,  &#34;solver2implicitTests&#34;: 110},
    {&#34;size&#34;: &#34;3&#34;, &#34;solver1queenPlacements&#34;: 129,  &#34;solver1methodCalls&#34;: 6723,  &#34;solver1squareReads&#34;: 1955,  &#34;solver1explicitTests&#34;: 2895,  &#34;solver1implicitTests&#34;: 3560,  &#34;solver2queenPlacements&#34;: 129,  &#34;solver2methodCalls&#34;: 3111,  &#34;solver2squareReads&#34;: 794,  &#34;solver2explicitTests&#34;: 1734,  &#34;solver2implicitTests&#34;: 1496},
    {&#34;size&#34;: &#34;4&#34;, &#34;solver1queenPlacements&#34;: 2516,  &#34;solver1methodCalls&#34;: 199258,  &#34;solver1squareReads&#34;: 60780,  &#34;solver1explicitTests&#34;: 76617,  &#34;solver1implicitTests&#34;: 96417,  &#34;solver2queenPlacements&#34;: 2516,  &#34;solver2methodCalls&#34;: 75974,  &#34;solver2squareReads&#34;: 20524,  &#34;solver2explicitTests&#34;: 36361,  &#34;solver2implicitTests&#34;: 33517},
    {&#34;size&#34;: &#34;5&#34;, &#34;solver1queenPlacements&#34;: 68405,  &#34;solver1methodCalls&#34;: 7768189,  &#34;solver1squareReads&#34;: 2434873,  &#34;solver1explicitTests&#34;: 2846091,  &#34;solver1implicitTests&#34;: 3553763,  &#34;solver2queenPlacements&#34;: 68405,  &#34;solver2methodCalls&#34;: 2569409,  &#34;solver2squareReads&#34;: 724748,  &#34;solver2explicitTests&#34;: 1135966,  &#34;solver2implicitTests&#34;: 1091183},
    {&#34;size&#34;: &#34;6&#34;, &#34;solver1queenPlacements&#34;: 2391495,  &#34;solver1methodCalls&#34;: 370248655,  &#34;solver1squareReads&#34;: 117983963,  &#34;solver1explicitTests&#34;: 132265835,  &#34;solver1implicitTests&#34;: 162657186,  &#34;solver2queenPlacements&#34;: 2391495,  &#34;solver2methodCalls&#34;: 109575700,  &#34;solver2squareReads&#34;: 31890143,  &#34;solver2explicitTests&#34;: 46172015,  &#34;solver2implicitTests&#34;: 45473931},
    {&#34;size&#34;: &#34;7&#34;, &#34;solver1queenPlacements&#34;: 102022809,  &#34;solver1methodCalls&#34;: 20677761079,  &#34;solver1squareReads&#34;: 6659907867,  &#34;solver1explicitTests&#34;: 7271931036,  &#34;solver1implicitTests&#34;: 8803458227,  &#34;solver2queenPlacements&#34;: 102022809,  &#34;solver2methodCalls&#34;: 5578385347,  &#34;solver2squareReads&#34;: 1660790226,  &#34;solver2explicitTests&#34;: 2272813395,  &#34;solver2implicitTests&#34;: 2273998451},
    {&#34;size&#34;: &#34;8&#34;, &#34;solver1queenPlacements&#34;: 5130659560,  &#34;solver1methodCalls&#34;: 1318173704582,  &#34;solver1squareReads&#34;: 427654527254,  &#34;solver1explicitTests&#34;: 458618310305,  &#34;solver1implicitTests&#34;: 547241304569,  &#34;solver2queenPlacements&#34;: 5130659560,  &#34;solver2methodCalls&#34;: 327956409502,  &#34;solver2squareReads&#34;: 99292315414,  &#34;solver2explicitTests&#34;: 130256098465,  &#34;solver2implicitTests&#34;: 131657880209}
    ];
var prefix1queenPlacementsGraph = Morris.Line({
    element: &#39;prefix1queenPlacements&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix1data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1queenPlacements&#39;, &#39;solver2queenPlacements&#39;],
    labels: [&#39;List brute-force&#39;, &#39;Queen constraint brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix1methodCallsGraph = Morris.Line({
    element: &#39;prefix1methodCalls&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix1data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1methodCalls&#39;, &#39;solver2methodCalls&#39;],
    labels: [&#39;List brute-force&#39;, &#39;Queen constraint brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix1squareReadsGraph = Morris.Line({
    element: &#39;prefix1squareReads&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix1data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1squareReads&#39;, &#39;solver2squareReads&#39;],
    labels: [&#39;List brute-force&#39;, &#39;Queen constraint brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix1explicitTestsGraph = Morris.Line({
    element: &#39;prefix1explicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix1data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1explicitTests&#39;, &#39;solver2explicitTests&#39;],
    labels: [&#39;List brute-force&#39;, &#39;Queen constraint brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix1implicitTestsGraph = Morris.Line({
    element: &#39;prefix1implicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix1data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1implicitTests&#39;, &#39;solver2implicitTests&#39;],
    labels: [&#39;List brute-force&#39;, &#39;Queen constraint brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});

&lt;/script&gt;

&lt;p&gt;The number of read square is lower with the queen constraint because the chessboard don&amp;rsquo;t need to be read to check the number of placed queens.&lt;/p&gt;

&lt;h2 id=&#34;use-a-two-dimensional-array-for-the-chessboard:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Use a two-dimensional array for the chessboard&lt;/h2&gt;

&lt;h3 id=&#34;explaination-1:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Explaination&lt;/h3&gt;

&lt;p&gt;The data structure used to represent the chessboard can be changed from a list of lists to a two-dimensional array. Data access is faster because it&amp;rsquo;s more direct without any method call, and the stored data can be a primitive type (boolean in this case intead of Boolean object).&lt;/p&gt;

&lt;h3 id=&#34;implementation-1:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the previous implementation with an two-dimensional array instead of a list of lists:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a 2 dimensional array. */
private final boolean[][] chessboard;
/** Current number of queens on the chessboard. */
private int placedQueens;

private void solve(final int x, final int y) {

    // Put a queen on the current position
    chessboard[x][y] = true;
    placedQueens++;

    // All queens on the chessboard then a solution may be present
    if (placedQueens &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    } else {

        // Recursive call to the next position
        final int nextX = (x + 1) % chessboardSize;
        // Switch to the next line
        if (0 == nextX) {

            // End of the chessboard check
            if (y + 1 &amp;lt; chessboardSize) {
                solve(nextX, y + 1);
            }
        } else {
            solve(nextX, y);
        }
    }

    // Remove the queen on the current position
    placedQueens--;
    chessboard[x][y] = false;

    // Recursive call to the next position
    final int nextX = (x + 1) % chessboardSize;
    // Switch to the next line
    if (0 == nextX) {

        // End of the chessboard check
        if (y + 1 &amp;lt; chessboardSize) {
            solve(nextX, y + 1);
        }
    } else {
        solve(nextX, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/BruteForceNQueensSolverArray.java&#34;&gt;BruteForceNQueensSolverArray&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks-1:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;th&gt;number of runs&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;84.20 µs&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2.89 ms&lt;/td&gt;
&lt;td&gt;5000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;94.52 ms&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;4.12 s&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;3.50 m&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 8x8 chessboard, the needed time to count all solutions is long!&lt;/p&gt;

&lt;h2 id=&#34;algorithms-comparisons-1:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Algorithms comparisons&lt;/h2&gt;

&lt;p&gt;Comparison of theses 2 algorithms:&lt;/p&gt;

&lt;div class=&#34;panel panel-default tab-box&#34;&gt;
    &lt;div class=&#34;panel-heading&#34;&gt;
        &lt;h3 class=&#34;panel-title&#34;&gt;
            &lt;i class=&#34;fa fa-signal&#34;&gt;&lt;/i&gt;Algorithms comparison
        &lt;/h3&gt;
        &lt;ul class=&#34;nav nav-tabs&#34;&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix2queenPlacementsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix2queenPlacementsGraph&#34;&gt;moves&lt;/a&gt;
            &lt;/li&gt;
            &lt;li class=&#34;active&#34;&gt;
                &lt;a href=&#34;#prefix2methodCallsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix2methodCallsGraph&#34;&gt;method calls&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix2squareReadsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix2squareReadsGraph&#34;&gt;reads&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix2explicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix2explicitTestsGraph&#34;&gt;tests&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#prefix2implicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;prefix2implicitTestsGraph&#34;&gt;loop tests&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&#34;panel-body&#34;&gt;
        &lt;div class=&#34;tab-content&#34;&gt;
            &lt;div id=&#34;prefix2queenPlacementsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Queen placements count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix2queenPlacements&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Array brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix2methodCallsTab&#34; class=&#34;tab-pane active&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Method calls count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix2methodCalls&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Array brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix2squareReadsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Square reads count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix2squareReads&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Array brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix2explicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Explicit tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix2explicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Array brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;prefix2implicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Loop tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;prefix2implicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Queen constraint brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;Array brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;

$(&#39;ul.nav a&#39;).on(&#39;shown.bs.tab&#39;, function (e) {
    var types = $(this).attr(&#34;data-identifier&#34;);
    var typesArray = types.split(&#34;,&#34;);
    $.each(typesArray, function (key, value) {
        eval(value + &#34;.redraw()&#34;);
        eval(value + &#34;.resizeHandler()&#34;);
    })
});

//Data
var prefix2data = [
    {&#34;size&#34;: &#34;1&#34;, &#34;solver1queenPlacements&#34;: 1,  &#34;solver1methodCalls&#34;: 19,  &#34;solver1squareReads&#34;: 4,  &#34;solver1explicitTests&#34;: 16,  &#34;solver1implicitTests&#34;: 17,  &#34;solver2queenPlacements&#34;: 1,  &#34;solver2methodCalls&#34;: 3,  &#34;solver2squareReads&#34;: 4,  &#34;solver2explicitTests&#34;: 16,  &#34;solver2implicitTests&#34;: 17},
    {&#34;size&#34;: &#34;2&#34;, &#34;solver1queenPlacements&#34;: 10,  &#34;solver1methodCalls&#34;: 194,  &#34;solver1squareReads&#34;: 46,  &#34;solver1explicitTests&#34;: 135,  &#34;solver1implicitTests&#34;: 110,  &#34;solver2queenPlacements&#34;: 10,  &#34;solver2methodCalls&#34;: 16,  &#34;solver2squareReads&#34;: 46,  &#34;solver2explicitTests&#34;: 135,  &#34;solver2implicitTests&#34;: 110},
    {&#34;size&#34;: &#34;3&#34;, &#34;solver1queenPlacements&#34;: 129,  &#34;solver1methodCalls&#34;: 3111,  &#34;solver1squareReads&#34;: 794,  &#34;solver1explicitTests&#34;: 1734,  &#34;solver1implicitTests&#34;: 1496,  &#34;solver2queenPlacements&#34;: 129,  &#34;solver2methodCalls&#34;: 213,  &#34;solver2squareReads&#34;: 794,  &#34;solver2explicitTests&#34;: 1734,  &#34;solver2implicitTests&#34;: 1496},
    {&#34;size&#34;: &#34;4&#34;, &#34;solver1queenPlacements&#34;: 2516,  &#34;solver1methodCalls&#34;: 75974,  &#34;solver1squareReads&#34;: 20524,  &#34;solver1explicitTests&#34;: 36361,  &#34;solver1implicitTests&#34;: 33517,  &#34;solver2queenPlacements&#34;: 2516,  &#34;solver2methodCalls&#34;: 4338,  &#34;solver2squareReads&#34;: 20524,  &#34;solver2explicitTests&#34;: 36361,  &#34;solver2implicitTests&#34;: 33517},
    {&#34;size&#34;: &#34;5&#34;, &#34;solver1queenPlacements&#34;: 68405,  &#34;solver1methodCalls&#34;: 2569409,  &#34;solver1squareReads&#34;: 724748,  &#34;solver1explicitTests&#34;: 1135966,  &#34;solver1implicitTests&#34;: 1091183,  &#34;solver2queenPlacements&#34;: 68405,  &#34;solver2methodCalls&#34;: 121545,  &#34;solver2squareReads&#34;: 724748,  &#34;solver2explicitTests&#34;: 1135966,  &#34;solver2implicitTests&#34;: 1091183},
    {&#34;size&#34;: &#34;6&#34;, &#34;solver1queenPlacements&#34;: 2391495,  &#34;solver1methodCalls&#34;: 109575700,  &#34;solver1squareReads&#34;: 31890143,  &#34;solver1explicitTests&#34;: 46172015,  &#34;solver1implicitTests&#34;: 45473931,  &#34;solver2queenPlacements&#34;: 2391495,  &#34;solver2methodCalls&#34;: 4339291,  &#34;solver2squareReads&#34;: 31890143,  &#34;solver2explicitTests&#34;: 46172015,  &#34;solver2implicitTests&#34;: 45473931},
    {&#34;size&#34;: &#34;7&#34;, &#34;solver1queenPlacements&#34;: 102022809,  &#34;solver1methodCalls&#34;: 5578385347,  &#34;solver1squareReads&#34;: 1660790226,  &#34;solver1explicitTests&#34;: 2272813395,  &#34;solver1implicitTests&#34;: 2273998451,  &#34;solver2queenPlacements&#34;: 102022809,  &#34;solver2methodCalls&#34;: 187923433,  &#34;solver2squareReads&#34;: 1660790226,  &#34;solver2explicitTests&#34;: 2272813395,  &#34;solver2implicitTests&#34;: 2273998451}
    ];
var prefix2queenPlacementsGraph = Morris.Line({
    element: &#39;prefix2queenPlacements&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix2data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1queenPlacements&#39;, &#39;solver2queenPlacements&#39;],
    labels: [&#39;Queen constraint brute-force&#39;, &#39;Array brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix2methodCallsGraph = Morris.Line({
    element: &#39;prefix2methodCalls&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix2data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1methodCalls&#39;, &#39;solver2methodCalls&#39;],
    labels: [&#39;Queen constraint brute-force&#39;, &#39;Array brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix2squareReadsGraph = Morris.Line({
    element: &#39;prefix2squareReads&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix2data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1squareReads&#39;, &#39;solver2squareReads&#39;],
    labels: [&#39;Queen constraint brute-force&#39;, &#39;Array brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix2explicitTestsGraph = Morris.Line({
    element: &#39;prefix2explicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix2data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1explicitTests&#39;, &#39;solver2explicitTests&#39;],
    labels: [&#39;Queen constraint brute-force&#39;, &#39;Array brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var prefix2implicitTestsGraph = Morris.Line({
    element: &#39;prefix2implicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: prefix2data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1implicitTests&#39;, &#39;solver2implicitTests&#39;],
    labels: [&#39;Queen constraint brute-force&#39;, &#39;Array brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});

&lt;/script&gt;

&lt;p&gt;The number of called methods is much lower when using an array because square reads and writes don&amp;rsquo;t need method calls anymore.&lt;/p&gt;

&lt;h2 id=&#34;next-optimisations:dbc45b4a636ebe887a66e72818a0ca96&#34;&gt;Next optimisations?&lt;/h2&gt;

&lt;p&gt;Next optimisations are tested in the part 3, click on the link below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8 queens puzzle brute-force solvers part 1</title>
      <link>http://sylvain-bugat.github.io/blog/2015/05/02/8-queens-puzzle-brute-force-solvers-part-1/</link>
      <pubDate>Sat, 02 May 2015 12:38:15 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/05/02/8-queens-puzzle-brute-force-solvers-part-1/</guid>
      <description>

&lt;h2 id=&#34;brute-force:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Brute-force&lt;/h2&gt;

&lt;h3 id=&#34;explanation:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Brute-force algorithms are also known as exhaustive algorithms, they consist of testing all possibilities with 8 (or more) queens on a chessboard like that for the first one:&lt;/p&gt;

&lt;div id=&#34;board&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;,
  b8: &#39;wQ&#39;,
  c8: &#39;wQ&#39;,
  d8: &#39;wQ&#39;,
  e8: &#39;wQ&#39;,
  f8: &#39;wQ&#39;,
  g8: &#39;wQ&#39;,
  h8: &#39;wQ&#39;
};
var board = new ChessBoard(&#39;board&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;In this case a limit of 8 queens is set to end the test and rollback the last placed queen, the next posibility tested will be:&lt;/p&gt;

&lt;div id=&#34;board2&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;,
  b8: &#39;wQ&#39;,
  c8: &#39;wQ&#39;,
  d8: &#39;wQ&#39;,
  e8: &#39;wQ&#39;,
  f8: &#39;wQ&#39;,
  g8: &#39;wQ&#39;,
  a7: &#39;wQ&#39;
};
var board2 = new ChessBoard(&#39;board2&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;It is clear that this algorithm is uneficient because the second placed queen is already invalid and next positionned and tested queens are just a waste of time. No solution can be found with 2 queens on the 2 first positions for example.&lt;/p&gt;

&lt;h2 id=&#34;uber-brute-force:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Uber-brute-force&lt;/h2&gt;

&lt;h3 id=&#34;explanation-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s possible to make an algorithm &lt;strong&gt;more uneficient&lt;/strong&gt; with no limit of simultaneous placed queens like this chessboard as the first tested &amp;ldquo;solution&amp;rdquo;:&lt;/p&gt;

&lt;div id=&#34;board3&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;, b8: &#39;wQ&#39;, c8: &#39;wQ&#39;, d8: &#39;wQ&#39;, e8: &#39;wQ&#39;, f8: &#39;wQ&#39;, g8: &#39;wQ&#39;, h8: &#39;wQ&#39;,
  a7: &#39;wQ&#39;, b7: &#39;wQ&#39;, c7: &#39;wQ&#39;, d7: &#39;wQ&#39;, e7: &#39;wQ&#39;, f7: &#39;wQ&#39;, g7: &#39;wQ&#39;, h7: &#39;wQ&#39;,
  a6: &#39;wQ&#39;, b6: &#39;wQ&#39;, c6: &#39;wQ&#39;, d6: &#39;wQ&#39;, e6: &#39;wQ&#39;, f6: &#39;wQ&#39;, g6: &#39;wQ&#39;, h6: &#39;wQ&#39;,
  a5: &#39;wQ&#39;, b5: &#39;wQ&#39;, c5: &#39;wQ&#39;, d5: &#39;wQ&#39;, e5: &#39;wQ&#39;, f5: &#39;wQ&#39;, g5: &#39;wQ&#39;, h5: &#39;wQ&#39;,
  a4: &#39;wQ&#39;, b4: &#39;wQ&#39;, c4: &#39;wQ&#39;, d4: &#39;wQ&#39;, e4: &#39;wQ&#39;, f4: &#39;wQ&#39;, g4: &#39;wQ&#39;, h4: &#39;wQ&#39;,
  a3: &#39;wQ&#39;, b3: &#39;wQ&#39;, c3: &#39;wQ&#39;, d3: &#39;wQ&#39;, e3: &#39;wQ&#39;, f3: &#39;wQ&#39;, g3: &#39;wQ&#39;, h3: &#39;wQ&#39;,
  a2: &#39;wQ&#39;, b2: &#39;wQ&#39;, c2: &#39;wQ&#39;, d2: &#39;wQ&#39;, e2: &#39;wQ&#39;, f2: &#39;wQ&#39;, g2: &#39;wQ&#39;, h2: &#39;wQ&#39;,
  a1: &#39;wQ&#39;, b1: &#39;wQ&#39;, c1: &#39;wQ&#39;, d1: &#39;wQ&#39;, e1: &#39;wQ&#39;, f1: &#39;wQ&#39;, g1: &#39;wQ&#39;, h1: &#39;wQ&#39;
};
var board3 = new ChessBoard(&#39;board3&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;This tested chessboard is just insane, only a brute-force program can test this as a solution. But this algorithm is a floor value to test speed-ups and optimisations.&lt;/p&gt;

&lt;h3 id=&#34;implementation:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is the slowest implementation I have done to resolve this puzzle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a list of lists. */
private final List&amp;lt;List&amp;lt;Boolean&amp;gt;&amp;gt; chessboard;

private void solve(final int x, final int y) {

    // Put a queen on the current position
    chessboard.get(x).set(y, Boolean.TRUE);

    // Test if the chessboard is a solution with exactly N queens
    if (checkSolutionChessboard()) {
        solutionCount++;
        print();
    }
    else {

        //Recursive call to the next position
        final int nextX = (x + 1) % chessboardSize;
        //Switch to the next line
        if (0 == nextX) {

            //End of the chessboard check
            if (y + 1 &amp;lt; chessboardSize) {
                solve(nextX, y + 1);
            }
        }
        else {
            solve(nextX, y);
        }
    }

    // Remove the queen on the current position
    chessboard.get(x).set(y, Boolean.FALSE);

    //Recursive call to the next position
    final int nextX = (x + 1) % chessboardSize;
    //Switch to the next line
    if (0 == nextX) {

        //End of the chessboard check
        if (y + 1 &amp;lt; chessboardSize) {
            solve(nextX, y + 1);
        }
    }
    else {
        solve(nextX, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/SlowBruteForceNQueensSolverWithListsNoQueensLimit.java&#34;&gt;SlowBruteForceNQueensSolverWithListsNoQueensLimit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This implementation has a lot of weakness:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The algorithm don&amp;rsquo;t stop after placing N queens&lt;/li&gt;
&lt;li&gt;The solution is checked by analyzing the full chessboard after placing each queen&lt;/li&gt;
&lt;li&gt;The chessboard is represented by list of lists&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first point is a complexity overkill because it greatly increases the number of moves required to test all possible solutions on the NxN chessboard. It&amp;rsquo;s a waste of time to test any combination with over N queens, a back-track is needed to test another untested combination.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4.57 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2.47 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;2h09m&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Even on 6x6 chessboard, the time needed to count all solutions is very long!&lt;/p&gt;

&lt;h2 id=&#34;brute-force-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Brute-force&lt;/h2&gt;

&lt;h3 id=&#34;implementation-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Implementation&lt;/h3&gt;

&lt;p&gt;This is just the previous implementation with a maximum limit of N placed queens at the same time on the chessboard:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a list of lists. */
private final List&amp;lt;List&amp;lt;Boolean&amp;gt;&amp;gt; chessboard;

private void solve(final int x, final int y) {

    // Put a queen on the current position
    chessboard.get(x).set(y, Boolean.TRUE);

    // All queens are sets then a solution may be present
    if (getPlacedQueens() &amp;gt;= chessboardSize) {
        if (checkSolutionChessboard()) {
            solutionCount++;
            print();
        }
    }
    else {

        // Recursive call to the next position
        final int nextX = (x + 1) % chessboardSize;
        // Switch to the next line
        if (0 == nextX) {

            // End of the chessboard check
            if (y + 1 &amp;lt; chessboardSize) {
                solve(nextX, y + 1);
            }
        }
        else {
            solve(nextX, y);
        }
    }

    // Remove the queen on the current position
    chessboard.get(x).set(y, Boolean.FALSE);

    // Recursive call to the next position
    final int nextX = (x + 1) % chessboardSize;
    // Switch to the next line
    if (0 == nextX) {

        // End of the chessboard check
        if (y + 1 &amp;lt; chessboardSize) {
            solve(nextX, y + 1);
        }
    }
    else {
        solve(nextX, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/SlowBruteForceNQueensSolverWithLists.java&#34;&gt;SlowBruteForceNQueensSolverWithLists&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This implementation is still very unefficient but is a lot faster because a lot of dead combination are not tested. This optimisation is the first little step to implement a back-tracking algorithm.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;chessboard size&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3.50 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;21.95 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;432.14 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;20.90 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;19.50 m&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;On 8x8 chessboard, the time needed to count all solutions is quite long!&lt;/p&gt;

&lt;h2 id=&#34;algorithms-comparisons:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Algorithms comparisons&lt;/h2&gt;

&lt;p&gt;Comparison of theses 2 algorithms:&lt;/p&gt;

&lt;div class=&#34;panel panel-default tab-box&#34;&gt;
    &lt;div class=&#34;panel-heading&#34;&gt;
        &lt;h3 class=&#34;panel-title&#34;&gt;
            &lt;i class=&#34;fa fa-signal&#34;&gt;&lt;/i&gt;Algorithms comparison
        &lt;/h3&gt;
        &lt;ul class=&#34;nav nav-tabs&#34;&gt;
            &lt;li class=&#34;active&#34;&gt;
                &lt;a href=&#34;#queenPlacementsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;queenPlacementsGraph&#34;&gt;moves&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#methodCallsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;methodCallsGraph&#34;&gt;method calls&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#squareReadsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;squareReadsGraph&#34;&gt;reads&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#explicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;explicitTestsGraph&#34;&gt;tests&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&#34;#implicitTestsTab&#34; data-toggle=&#34;tab&#34; data-identifier=&#34;implicitTestsGraph&#34;&gt;loop tests&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;div class=&#34;panel-body&#34;&gt;
        &lt;div class=&#34;tab-content&#34;&gt;
            &lt;div id=&#34;queenPlacementsTab&#34; class=&#34;tab-pane active&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Queen placements count
                    &lt;/div&gt;
                    &lt;div id=&#34;queenPlacements&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Uber brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;List brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;methodCallsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Method calls count
                    &lt;/div&gt;
                    &lt;div id=&#34;methodCalls&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Uber brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;List brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;squareReadsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Square reads count
                    &lt;/div&gt;
                    &lt;div id=&#34;squareReads&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Uber brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;List brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;explicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Explicit tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;explicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Uber brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;List brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div id=&#34;implicitTestsTab&#34; class=&#34;tab-pane&#34;&gt;
                &lt;div class=&#34;row&#34;&gt;
                    &lt;div class=&#34;caption&#34;&gt;
                        Loop tests count
                    &lt;/div&gt;
                    &lt;div id=&#34;implicitTests&#34;&gt;&lt;/div&gt;
                    &lt;div class=&#34;legend&#34;&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #A52A2A;&#34;&gt;Uber brute-force&lt;/span&gt;
                        &lt;span class=&#34;label&#34; style=&#34;background-color: #72A0C1;&#34;&gt;List brute-force&lt;/span&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;

$(&#39;ul.nav a&#39;).on(&#39;shown.bs.tab&#39;, function (e) {
    var types = $(this).attr(&#34;data-identifier&#34;);
    var typesArray = types.split(&#34;,&#34;);
    $.each(typesArray, function (key, value) {
        eval(value + &#34;.redraw()&#34;);
        eval(value + &#34;.resizeHandler()&#34;);
    })
});

//Data
var data = [
    {&#34;size&#34;: &#34;1&#34;, &#34;solver1queenPlacements&#34;: 1,  &#34;solver1methodCalls&#34;: 22,  &#34;solver1squareReads&#34;: 5,  &#34;solver1explicitTests&#34;: 16,  &#34;solver1implicitTests&#34;: 20,  &#34;solver2queenPlacements&#34;: 1,  &#34;solver2methodCalls&#34;: 23,  &#34;solver2squareReads&#34;: 5,  &#34;solver2explicitTests&#34;: 17,  &#34;solver2implicitTests&#34;: 21},
    {&#34;size&#34;: &#34;2&#34;, &#34;solver1queenPlacements&#34;: 15,  &#34;solver1methodCalls&#34;: 408,  &#34;solver1squareReads&#34;: 106,  &#34;solver1explicitTests&#34;: 225,  &#34;solver1implicitTests&#34;: 236,  &#34;solver2queenPlacements&#34;: 10,  &#34;solver2methodCalls&#34;: 324,  &#34;solver2squareReads&#34;: 86,  &#34;solver2explicitTests&#34;: 175,  &#34;solver2implicitTests&#34;: 200},
    {&#34;size&#34;: &#34;3&#34;, &#34;solver1queenPlacements&#34;: 511,  &#34;solver1methodCalls&#34;: 19245,  &#34;solver1squareReads&#34;: 5393,  &#34;solver1explicitTests&#34;: 8277,  &#34;solver1implicitTests&#34;: 9534,  &#34;solver2queenPlacements&#34;: 129,  &#34;solver2methodCalls&#34;: 6723,  &#34;solver2squareReads&#34;: 1955,  &#34;solver2explicitTests&#34;: 2895,  &#34;solver2implicitTests&#34;: 3560},
    {&#34;size&#34;: &#34;4&#34;, &#34;solver1queenPlacements&#34;: 65531,  &#34;solver1methodCalls&#34;: 3600248,  &#34;solver1squareReads&#34;: 1069020,  &#34;solver1explicitTests&#34;: 1402825,  &#34;solver1implicitTests&#34;: 1668602,  &#34;solver2queenPlacements&#34;: 2516,  &#34;solver2methodCalls&#34;: 199258,  &#34;solver2squareReads&#34;: 60780,  &#34;solver2explicitTests&#34;: 76617,  &#34;solver2implicitTests&#34;: 96417},
    {&#34;size&#34;: &#34;5&#34;, &#34;solver1queenPlacements&#34;: 33554379,  &#34;solver1methodCalls&#34;: 2720078953,  &#34;solver1squareReads&#34;: 839584223,  &#34;solver1explicitTests&#34;: 1008454787,  &#34;solver1implicitTests&#34;: 1208950192,  &#34;solver2queenPlacements&#34;: 68405,  &#34;solver2methodCalls&#34;: 7768189,  &#34;solver2squareReads&#34;: 2434873,  &#34;solver2explicitTests&#34;: 2846091,  &#34;solver2implicitTests&#34;: 3553763}
    ];
var queenPlacementsGraph = Morris.Line({
    element: &#39;queenPlacements&#39;,
    hideHover: &#39;auto&#39;,
    data: data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1queenPlacements&#39;, &#39;solver2queenPlacements&#39;],
    labels: [&#39;Uber brute-force&#39;, &#39;List brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var methodCallsGraph = Morris.Line({
    element: &#39;methodCalls&#39;,
    hideHover: &#39;auto&#39;,
    data: data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1methodCalls&#39;, &#39;solver2methodCalls&#39;],
    labels: [&#39;Uber brute-force&#39;, &#39;List brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var squareReadsGraph = Morris.Line({
    element: &#39;squareReads&#39;,
    hideHover: &#39;auto&#39;,
    data: data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1squareReads&#39;, &#39;solver2squareReads&#39;],
    labels: [&#39;Uber brute-force&#39;, &#39;List brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var explicitTestsGraph = Morris.Line({
    element: &#39;explicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1explicitTests&#39;, &#39;solver2explicitTests&#39;],
    labels: [&#39;Uber brute-force&#39;, &#39;List brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});
var implicitTestsGraph = Morris.Line({
    element: &#39;implicitTests&#39;,
    hideHover: &#39;auto&#39;,
    data: data,
    xkey: &#39;size&#39;,
    ykeys: [&#39;solver1implicitTests&#39;, &#39;solver2implicitTests&#39;],
    labels: [&#39;Uber brute-force&#39;, &#39;List brute-force&#39;],
    resize: true,
    parseTime: false,
    lineColors: [&#39;#A52A2A&#39;, &#39;#72A0C1&#39;],
    yLabelFormat: function(y) { return y.toLocaleString(); },
    xLabelFormat: function(obj) { return (obj.x + 1).toLocaleString(); },
});

&lt;/script&gt;

&lt;p&gt;All benchmarked operations with the uber-brute-force algorithm became huge very quickly and the speed up of only placing a maximum of N queens on a NxN chessboard is amazing!&lt;/p&gt;

&lt;h2 id=&#34;next-optimisations:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Next optimisations?&lt;/h2&gt;

&lt;p&gt;Next optimisations are tested in the part 2, click on the link below.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>8 queens puzzle introduction</title>
      <link>http://sylvain-bugat.github.io/blog/2015/04/28/8-queens-puzzle-introduction/</link>
      <pubDate>Tue, 28 Apr 2015 23:12:21 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/04/28/8-queens-puzzle-introduction/</guid>
      <description>

&lt;p&gt;This post is the first of a article series about the 8/N queens puzzle solving.&lt;/p&gt;

&lt;h2 id=&#34;introduction:2767292a573dc549b9b4297b701af3ab&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://en.wikipedia.org/wiki/Eight_queens_puzzle&#34;&gt;8 queens on a chessboard&lt;/a&gt; is a classic puzzle which consists of placing 8 queens on a chessboard with only one queen on each row, column and diagonal, you can try it with this chessboard (errors are not visible yet):&lt;/p&gt;

&lt;div id=&#34;board&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;p&gt;&lt;input type=&#34;button&#34; id=&#34;clearButton&#34; value=&#34;Clear chessboard&#34;&gt;&lt;/input&gt;&lt;/p&gt;

&lt;script&gt;
    var board = new ChessBoard(&#39;board&#39;, {
        draggable: true,
        dropOffBoard: &#39;trash&#39;,
        sparePieces: true,
        showNotation: false
    });
    $(&#39;#clearButton&#39;).on(&#39;click&#39;, board.clear);
&lt;/script&gt;

&lt;p&gt;This Javascript is based on &lt;a href=&#34;http://chessboardjs.com/&#34;&gt;chessboard.js.com&lt;/a&gt; (&lt;a href=&#34;https://github.com/oakmac/chessboardjs/&#34;&gt;GitHub link&lt;/a&gt;) under the &lt;a href=&#34;https://github.com/oakmac/chessboardjs/blob/master/LICENSE&#34;&gt;MIT license&lt;/a&gt;. The modified version of this script can be found &lt;a href=&#34;https://github.com/Sylvain-Bugat/blog-sources/blob/master/themes/hyde-x/static/js/chessboard/chessboard-0.3.0.js&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Queen image is from &lt;a href=&#34;http://pixabay.com/en/chess-queen-meeple-white-game-36310/&#34;&gt;Pixabay&lt;/a&gt; under the &lt;a href=&#34;http://creativecommons.org/publicdomain/zero/1.0/deed&#34;&gt;CC0 Public Domain&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;extention-to-n-queens:2767292a573dc549b9b4297b701af3ab&#34;&gt;Extention to N queens&lt;/h3&gt;

&lt;p&gt;This puzzle can be extended to N queens on a N x N chessboard and a higher value of N increase needed operations to find all solutions.&lt;/p&gt;

&lt;p&gt;All implemented algorithm in this series of posts can count solutions on a chessboard of size N.&lt;/p&gt;

&lt;h3 id=&#34;solutions-of-the-puzzle:2767292a573dc549b9b4297b701af3ab&#34;&gt;Solutions of the puzzle&lt;/h3&gt;

&lt;p&gt;Known number of solutions for N from 1 to 26 are:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;number of solutions&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;40&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;92&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;352&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;724&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;2 680&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;14 200&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;73 712&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;365 596&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;2 279 184&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;14 772 512&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;95 815 104&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;666 090 624&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;4 968 057 848&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;39 029 188 884&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;314 666 222 712&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;2 691 008 701 644&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;24 233 937 684 440&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;227 514 171 973 736&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;2 207 893 435 808 352&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;26&lt;/td&gt;
&lt;td&gt;22 317 699 616 364 044&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Source: sequence &lt;a href=&#34;http://oeis.org/A000170&#34;&gt;A000170&lt;/a&gt; on &lt;a href=&#34;http://oeis.org/&#34;&gt;OEIS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On a classic chessboard there is 92 distinct solutionsn and this chessboard is one solution:&lt;/p&gt;

&lt;div id=&#34;solutionBoard&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;
    var positions = {
        c8: &#39;wQ&#39;,
        e7: &#39;wQ&#39;,
        h6: &#39;wQ&#39;,
        d5: &#39;wQ&#39;,
        a4: &#39;wQ&#39;,
        g3: &#39;wQ&#39;,
        b2: &#39;wQ&#39;,
        f1: &#39;wQ&#39;
    };
    new ChessBoard(&#39;solutionBoard&#39;, {
        position: positions,
        showNotation: false
    });
&lt;/script&gt;

&lt;h2 id=&#34;resolve-the-puzzle:2767292a573dc549b9b4297b701af3ab&#34;&gt;Resolve the puzzle&lt;/h2&gt;

&lt;p&gt;This puzzle can be solved with various algorithms. It is quite easy to resolve when N is low and it is a good pratice for testing various algorithms and optimisations.&lt;/p&gt;

&lt;p&gt;Next posts of this series will explain brute-force and back-tracking algorithms and possible optimisations with some benchmarks to compare. Algorithms will be implemented in &lt;strong&gt;Java&lt;/strong&gt; and all shown code and algorithms are on this &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers&#34;&gt;GitHub project&lt;/a&gt; and are under the &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/LICENSE&#34;&gt;MIT license&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;why-implementations-are-in-java:2767292a573dc549b9b4297b701af3ab&#34;&gt;Why implementations are in Java?&lt;/h3&gt;

&lt;p&gt;Java is my main programming language and is very popular.&lt;/p&gt;

&lt;p&gt;Because of the Java runtime machine (JVM) overhead, Java programs can be slower than assembler/compiled languages(C, C++, Go, &amp;hellip;) programs for CPU-bound programs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;But a fast Java program is faster than a slow assembler/C program because of algorithm optimisations.&lt;/strong&gt;
Nevertheless a same algortihm implemented in Java and in a optimized compiled language should be executed a faster by the compiled language program in most cases.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:2767292a573dc549b9b4297b701af3ab&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;Benchmarks will be implemented in Java with multiple runs of the same algorithms with the fastest 20% and the slowest 20% runs discarding.&lt;/p&gt;

&lt;p&gt;To compare diferent benchmarks, they need to be run on the same computer at the same time (sequentially), that will be the case in theses posts.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>