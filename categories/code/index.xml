<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code on Batch cavern</title>
    <link>http://sylvain-bugat.github.io/categories/code/</link>
    <description>Recent content in Code on Batch cavern</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 May 2015 12:38:15 +0200</lastBuildDate>
    <atom:link href="http://sylvain-bugat.github.io/categories/code/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>8 queens puzzle brute-force solvers part 1</title>
      <link>http://sylvain-bugat.github.io/blog/2015/05/02/8-queens-puzzle-brute-force-solvers-part-1/</link>
      <pubDate>Sat, 02 May 2015 12:38:15 +0200</pubDate>
      
      <guid>http://sylvain-bugat.github.io/blog/2015/05/02/8-queens-puzzle-brute-force-solvers-part-1/</guid>
      <description>

&lt;h2 id=&#34;explanations:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Explanations&lt;/h2&gt;

&lt;h3 id=&#34;brute-force:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Brute-force&lt;/h3&gt;

&lt;p&gt;Brute-force algorithms are also known as exhaustive algorithms, they consist of testing all possibilities with 8 (or more) queens on a chessboard like that for the first one:&lt;/p&gt;

&lt;div id=&#34;board&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;,
  b8: &#39;wQ&#39;,
  c8: &#39;wQ&#39;,
  d8: &#39;wQ&#39;,
  e8: &#39;wQ&#39;,
  f8: &#39;wQ&#39;,
  g8: &#39;wQ&#39;,
  h8: &#39;wQ&#39;
};
var board = new ChessBoard(&#39;board&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;In this case a limit of 8 queens is set to end the test and rollback the last placed queen, the next posibility tested will be:&lt;/p&gt;

&lt;div id=&#34;board2&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;,
  b8: &#39;wQ&#39;,
  c8: &#39;wQ&#39;,
  d8: &#39;wQ&#39;,
  e8: &#39;wQ&#39;,
  f8: &#39;wQ&#39;,
  g8: &#39;wQ&#39;,
  a7: &#39;wQ&#39;
};
var board2 = new ChessBoard(&#39;board2&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;It is clear that this algorithm is uneficient because the second placed queen is already invalid and next positionned and tested queens are just a waste of time. No solution can be found with 2 queens on the 2 first positions for example.&lt;/p&gt;

&lt;h3 id=&#34;uber-brute-force:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Uber-brute-force&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s possible to make an algorithm &lt;strong&gt;more uneficient&lt;/strong&gt; with no limit of simultaneous placed queens like this chessboard as the first tested &amp;ldquo;solution&amp;rdquo;:&lt;/p&gt;

&lt;div id=&#34;board3&#34; style=&#34;width: 400px&#34;&gt;&lt;/div&gt;

&lt;script&gt;

var position = {
  a8: &#39;wQ&#39;, b8: &#39;wQ&#39;, c8: &#39;wQ&#39;, d8: &#39;wQ&#39;, e8: &#39;wQ&#39;, f8: &#39;wQ&#39;, g8: &#39;wQ&#39;, h8: &#39;wQ&#39;,
  a7: &#39;wQ&#39;, b7: &#39;wQ&#39;, c7: &#39;wQ&#39;, d7: &#39;wQ&#39;, e7: &#39;wQ&#39;, f7: &#39;wQ&#39;, g7: &#39;wQ&#39;, h7: &#39;wQ&#39;,
  a6: &#39;wQ&#39;, b6: &#39;wQ&#39;, c6: &#39;wQ&#39;, d6: &#39;wQ&#39;, e6: &#39;wQ&#39;, f6: &#39;wQ&#39;, g6: &#39;wQ&#39;, h6: &#39;wQ&#39;,
  a5: &#39;wQ&#39;, b5: &#39;wQ&#39;, c5: &#39;wQ&#39;, d5: &#39;wQ&#39;, e5: &#39;wQ&#39;, f5: &#39;wQ&#39;, g5: &#39;wQ&#39;, h5: &#39;wQ&#39;,
  a4: &#39;wQ&#39;, b4: &#39;wQ&#39;, c4: &#39;wQ&#39;, d4: &#39;wQ&#39;, e4: &#39;wQ&#39;, f4: &#39;wQ&#39;, g4: &#39;wQ&#39;, h4: &#39;wQ&#39;,
  a3: &#39;wQ&#39;, b3: &#39;wQ&#39;, c3: &#39;wQ&#39;, d3: &#39;wQ&#39;, e3: &#39;wQ&#39;, f3: &#39;wQ&#39;, g3: &#39;wQ&#39;, h3: &#39;wQ&#39;,
  a2: &#39;wQ&#39;, b2: &#39;wQ&#39;, c2: &#39;wQ&#39;, d2: &#39;wQ&#39;, e2: &#39;wQ&#39;, f2: &#39;wQ&#39;, g2: &#39;wQ&#39;, h2: &#39;wQ&#39;,
  a1: &#39;wQ&#39;, b1: &#39;wQ&#39;, c1: &#39;wQ&#39;, d1: &#39;wQ&#39;, e1: &#39;wQ&#39;, f1: &#39;wQ&#39;, g1: &#39;wQ&#39;, h1: &#39;wQ&#39;
};
var board3 = new ChessBoard(&#39;board3&#39;, {
    position: position,
    showNotation: false
});

&lt;/script&gt;

&lt;p&gt;This tested chessboard is just insane only a brute-force program can test this as a solution. But this algorithm is a floor value to test speed-ups and optimisations.&lt;/p&gt;

&lt;h2 id=&#34;implementations:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Implementations&lt;/h2&gt;

&lt;h3 id=&#34;uber-brute-force-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Uber-brute-force&lt;/h3&gt;

&lt;p&gt;This is the slowest implementation I have done to resolve this puzzle:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/** Chessboard represented by a list of lists. */
private final List&amp;lt;List&amp;lt;Boolean&amp;gt;&amp;gt; chessboard;

private void solve(final int x, final int y) {

	// Put a queen on the current position
	chessboard.get(x).set(y, Boolean.TRUE);

	// Test if the chessboard is a solution with exactly N queens
	if (checkSolutionChessboard()) {
		solutionCount++;
		print();
	}
	else {

		//Recursive call to the next position
		final int nextX = (x + 1) % chessboardSize;
		//Switch to the next line
		if (0 == nextX) {

			//End of the chessboard check
			if (y + 1 &amp;lt; chessboardSize) {
				solve(nextX, y + 1);
			}
		}
		else {
			solve(nextX, y);
		}
	}

	// Remove the queen on the current position
	chessboard.get(x).set(y, Boolean.FALSE);

	//Recursive call to the next position
	final int nextX = (x + 1) % chessboardSize;
	//Switch to the next line
	if (0 == nextX) {

		//End of the chessboard check
		if (y + 1 &amp;lt; chessboardSize) {
			solve(nextX, y + 1);
		}
	}
	else {
		solve(nextX, y);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/SlowBruteForceNQueensSolverWithListsNoQueensLimit.java&#34;&gt;SlowBruteForceNQueensSolverWithListsNoQueensLimit&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This implementation has a lot of weakness:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The algorithm don&amp;rsquo;t stop after placing N queens&lt;/li&gt;
&lt;li&gt;The solution is checked by analyzing the full chessboard after placing each queen&lt;/li&gt;
&lt;li&gt;The chessboard is represented by list of lists&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first point is a complexity overkill because it greatly increases the number of move required to test all possible solutions on the NxN chessboard. It&amp;rsquo;s a waste of time to test any combination with over N queens, a back-track is needed to test another untested combination.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4,57 ms&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;2,47 s&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;brute-force-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Brute-force&lt;/h3&gt;

&lt;p&gt;This is just the previous implementation with a maximum limit of N placed queens at the same time on the chessboard:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;private void solve(final int x, final int y) {

	// Put a queen on the current position
	chessboard.get(x).set(y, Boolean.TRUE);

	// All queens are sets on the chessboard then a solution may be present
	if (getPlacedQueens() &amp;gt;= chessboardSize) {
		if (checkSolutionChessboard()) {
			solutionCount++;
			print();
		}
	}
	else {

		// Recursive call to the next position
		final int nextX = (x + 1) % chessboardSize;
		// Switch to the next line
		if (0 == nextX) {

			// End of the chessboard check
			if (y + 1 &amp;lt; chessboardSize) {
				solve(nextX, y + 1);
			}
		}
		else {
			solve(nextX, y);
		}
	}

	// Remove the queen on the current position
	chessboard.get(x).set(y, Boolean.FALSE);

	// Recursive call to the next position
	final int nextX = (x + 1) % chessboardSize;
	// Switch to the next line
	if (0 == nextX) {

		// End of the chessboard check
		if (y + 1 &amp;lt; chessboardSize) {
			solve(nextX, y + 1);
		}
	}
	else {
		solve(nextX, y);
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The complete implementation is in this source file &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers/blob/master/src/main/java/com/github/sbugat/nqueens/solvers/bruteforce/SlowBruteForceNQueensSolverWithLists.java&#34;&gt;SlowBruteForceNQueensSolverWithLists&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This implementation is still very unefficient but is a lot faster because a lot of dead combination are not tested. This optimisation is the first little step to implement a back-tracking algorithm.&lt;/p&gt;

&lt;h3 id=&#34;benchmarks-1:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Benchmarks&lt;/h3&gt;

&lt;p&gt;These benchmarks are done on a &lt;a href=&#34;http://ark.intel.com/products/52210/Intel-Core-i5-2500K-Processor-6M-Cache-up-to-3_70-GHz&#34;&gt;Core i5 2500K&lt;/a&gt;:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;N&lt;/th&gt;
&lt;th&gt;execution time&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;?&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;too long&amp;hellip;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;next-optimisations:02e494252b7a2aa6ccffd65c467a0932&#34;&gt;Next optimisations?&lt;/h2&gt;

&lt;p&gt;Other optimisations will be tested in the part 2, stay tuned of go to the &lt;a href=&#34;https://github.com/Sylvain-Bugat/N-queens-puzzle-solvers&#34;&gt;GitHub project&lt;/a&gt; to have some algorithms preview!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>